<!DOCTYPE html>
<!--[if lt IE 8 ]><html class="no-js ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="no-js ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 8)|!(IE)]><!--><html class="no-js" lang="en"> <!--<![endif]-->
<head>

   <!--- Basic Page Needs
   ================================================== -->
   <meta charset="utf-8">
	<title>Charlie's Resume</title>
	<meta name="description" content="">
	<meta name="author" content="">

   <!-- Mobile Specific Metas
   ================================================== -->
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<!-- CSS
    ================================================== -->
   <link rel="stylesheet" href="css/default.css">
	<link rel="stylesheet" href="css/layout.css">
   <link rel="stylesheet" href="css/media-queries.css">
   <link rel="stylesheet" href="css/magnific-popup.css">

   <!-- Script
   ================================================== -->
   <script src="js/modernizr.js"></script>
   <script src="js/main.js"></script>
   <script src="js/counter.js"></script>

   <!-- Favicons
	================================================== -->
	<link rel="shortcut icon" href="favicon.png" >

</head>

<body>

   <!-- Header
   ================================================== -->
   <header id="home">

      <nav id="nav-wrap">

         <a class="mobile-btn" href="#nav-wrap" title="Show navigation">Show navigation</a>
	      <a class="mobile-btn" href="#" title="Hide navigation">Hide navigation</a>

         <ul id="nav" class="nav">
            <li class="current"><a class="smoothscroll" href="#home">Home</a></li>
            <li><a href="https://resume.cmdevelop.com">Back</a></li>

         </ul> <!-- end #nav -->

      </nav> <!-- end #nav-wrap -->

      <div class="row banner">
         <div class="banner-text">
            <h1 class="responsive-headline">The Cloud Resume Challenge - Azure</h1>
            <p>The Cloud Resume Challenge is a hands-on, end-to-end cloud engineering project designed to demonstrate your practical cloud skills by building and deploying a resume website using real cloud infrastructure. It was created by Forrest Brazeal, a cloud educator, to help aspiring and current cloud professionals showcase their skills beyond certifications.
               <br></br>
                  If you would like to take on this challenge yourself, you can read more about it <span><a href="https://cloudresumechallenge.dev/docs/the-challenge/azure/" target="_blank">here</a></span></p>
         </div>
      </div>

      <p class="scrolldown">
         <a class="smoothscroll" href="#post"><i class="icon-down-circle"></i></a>
      </p>

   </header> <!-- Header End -->

   <!-- Resume Section
   ================================================== -->
   <section id="post">

      <!-- Step One
      ----------------------------------------------- -->
      <div class="row work">
         <div class="three columns header-col">
            <h1><span>1. Certification</span></h1>
         </div>
         <div class="nine columns main-col">
            <div class="row item">
               <div class="twelve columns">
                  <p class >I had already completed various Microsoft Certifications, including the AZ-900. This was as simple as building out the HTML to state this on the site, that I had completed this certification<br></br>
                  I also chose to provide a verifiable link to the certificates, so they can be verified. 
                  </p>
               </div>
            </div> <!-- item end -->
         </div> <!-- main-col end -->
      </div> <!-- End 1. Certification -->
      <div class="row work">
         <div class="three columns header-col">
            <h1><span>2. HTML</span></h1>
         </div>
         <div class="nine columns main-col">
            <div class="row item">
               <div class="twelve columns">
                  <p>To be truthfully honest, I did not feel that further developing my rusty HTML skillset, by building out the bare bones of the site myself. I leveraged a <a href="https://www.styleshout.com/free-templates/ceevee/">Template by CeeVee</a>, to speed up the process, so I could focus my attention on the more exciting stuff - like Azure! 
                  <br></br>
                  It's worth noting that my rusty skillset allowed me to modify the template, and make the site feel and look like mine. I even went the extra mile here, and decided to implement an additional page for my very own blog, so I could post this : ) </p>
               </div>
            </div> <!-- item end -->
         </div> <!-- main-col end -->
      </div> <!-- End 2. HTML -->
      <div class="row work">
         <div class="three columns header-col">
            <h1><span>3. CSS</span></h1>
         </div>
         <div class="nine columns main-col">
            <div class="row item">
               <div class="twelve columns">
                  <p>This was very much the same story as the HTML...I personally feel like this is a waste of time, when there are toolsets that can be leveraged to increase efficiency.
                     <br></br>
                  I did again modify these templates to get the design I wanted, but maybe one day when I have an unlimited amount of time, I will come and revisit and try my hand at building the site in CSS from scratch. </p>
               </div>
            </div> <!-- item end -->
         </div> <!-- main-col end -->
      </div> <!-- End 3. CSS -->
      <div class="row work">
         <div class="three columns header-col">
            <h1><span>4. Static Website</span></h1>
         </div>
         <div class="nine columns main-col">
            <div class="row item">
               <div class="twelve columns">
                  <p>Before I got started with anything, I decided to configure a budget on my Azure Subscription - that would notify me if my cloud spend cost more than AUD$10 a month, as I wanted this solution to account for minimal cloud spend, and not be shocked by a crazy Azure invoice, if I left some of my other projects running by accident.
                     <br></br>
                     If you are new to the Azure world, I would recommend you do the same, so you don't end up like this <a href="https://www.reddit.com/r/AZURE/comments/1fdci4v/accidentally_ran_up_a_charge_of_1k_when_learning/" target="_blank">person</a>
                     <br></br>
                     So the details provided by The Cloud Resume Challenge, were pretty on the nose here. They stated that Azure Storage should be used, so I deployed an Azure Storage Account, and got to the configuration.
                     <br></br>
                     I knew from prior experience within Azure, that the blob service offers a feature called <a href="https://learn.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website" target="_blank">Static Website</a>. Once enabled, this created a $web blob container - that will be used to hold the flat files for the website hosting. I specified my index and error page HTML documents and clicked save to ensure this was enabled.  
                     <br></br>
                     I was then able to browse to the primary endpoint, provided by the Static Web enabled Storage Account - and voila, I could see my site on the internet!! :D 
                  </p>
                  <img src="./images/AzureStorage.png">
               </div>
            </div> <!-- item end -->
         </div> <!-- main-col end -->
      </div> <!-- End 4. Static Website -->
      <div class="row work">
         <div class="three columns header-col">
            <h1><span>5. HTTPS & 6. DNS</span></h1>
         </div>
         <div class="nine columns main-col">
            <div class="row item">
               <div class="twelve columns">
                  <p>Well, I could argue that it was already using HTTPS, as the Static Web enabled Storage Account already had HTTPS support, via the primary endpoint. However, the next step specified I use a custom domain name for my static site. so the primary endpoint on the Storage Account was no longer going to cut it.
                  <br></br>
                  The challenge pointed me toward using an Azure CDN / Front Door & Azure DNS. I had already registered cmdevelop.com with another domain registar and paid for the next few years, so I chose to not use Azure DNS to keep costs down. I had some very limited experience with CDN's or <a href="https://www.cloudflare.com/learning/cdn/what-is-a-cdn/"> content delivery networks</a>, and understood the fundamentals so I delved into understanding the difference between Azure Front Door and the classic CDN standard offering 
                  <br></br>
                  The main difference between these two services, is that Azure Front Door is more optimized toward Dynamic Delivery (ie, Applications or Services that serve content that frequently changes, or is personalized based on user interactions, or other factors), where as the CDN offering is optimized more towards static site delivery. These services both supported custom domains over HTTPS and looked to be fairly similar for the purposes that I would require the services for. I then found that the CDN was a much cheaper option to host on Azure, so I picked this service and deployed it.
                  <br></br>
                  I waited for my new CDN to deploy, and then found I needed to deploy a CDN endpoint, so I could map this back to the origin, so I created this specifying a unique name, set my origin type to Storage static website, as this made the most sense. This then allowed me to select my primary endpoint from my static web storage account, as the Origin hostname. I then chose to leave everything else default, as it was prefilled. 
               </p>
               <img src="./images/CDNEndpoint.png">
               <p>I could now access my website directly, using HTTPS & the CDN endpoint. The CDN was using a cached copy of static site, to display the content. I verified this by deleting the index.html file within the $web container, and seeing if this modified the live site, that was accessible via the CDN endpoint. 
                  <br></br>
                  As expected, this was not updated, but I could see the update directly via the primary endpoint on the static web enabled storage account. This displayed the 404 page, as this did not hold a cached copy. I then purged my CDN via the Azure Portal, waited 5 minutes and the 404 page was now also visible via the CDN endpoint. This is a critical aspect of the functionality of a CDN, as it allowed the files on the site to be able to be deleted, and replaced without affecting the live copy - once I was ready for the changes to be visible to the live copy of the site - I purged the CDN cache, so it could now reference the most up to date data. 
                  <br></br>
                  Great! My CDN is working exactly as I was expecting it to, next I focused my attention on configuring my custom domain name. First of all, I needed to configure my DNS record, so I logged into my domain registrars portal and created a CNAME that pointed my website / domain hostname at my Endpoint hostname.
               </p>
                  <img src="./images/CNAME.png">
               <p>
                  I then returned to the Azure Portal, added the custom domain and clicked Save. I waited for this to apply, then clicked on the newly added domain name, and enabled the HTTPS feature. This took some time to complete, as it needs to complete validation and certificate deployment tasks. 
                  <br></br>
                  Once this had completed, I was able to access my site directly via my custom domain name, over HTTPS - https://resume.cmdevelop.com
                  <br></br>
                  There are some other cool features included in the CDN, that allows you to Geo-Filter & Block any requests originating from certain countries. I decided to leave most of my configuration default, but I challenge you to test these features out.
               </p>
               </div>
            </div> <!-- item end -->
         </div> <!-- main-col end -->
      </div> <!-- End 5. HTTPS & 6. DNS -->
      <div class="row work">
         <div class="three columns header-col">
            <h1><span>7. Source Control</span></h1>
         </div>
         <div class="nine columns main-col">
            <div class="row item">
               <div class="twelve columns">
                  <p>So, the next step here was to develop some Javascript! My Javascript skills were very rusty, so before I got started I wanted to make sure I setup some source control, to avoid accidentally deleting any of my existing or future code.
                     <br></br>
                     I was already pretty familar with git, and utilizing Github to store projects I am working on, so I initialized a new git repository on my machine and committed these changes to my repository, I also spent some time building out the framework of my ReadMe file. This is my first public repository, so I wanted to make sure this looked presentable and professional for anyone that stumbles across this.
                  </p>
                  <div style="text-align: center;">
                     <img src="./images/git.png">
                  </div>
                  <p>   
                     The challenge does state that I should not be manually updating either my back-end or front-end, and that they should automatically update when a change is made to the code. This will be addressed seperately within the CI/CD chapters of this blog post.
                     <br></br>
                     It also suggested that I utilize two different Github repositories, but I chose to keep it simple with one, and target my yml workflows to individual folders for the backend & frontend.
                  </p>
               </div>
            </div> <!-- item end -->
         </div> <!-- main-col end -->
      </div> <!-- End 7. Source Control -->
      <div class="row work">
         <div class="three columns header-col">
            <h1><span>8. CI/CD Front End</span></h1>
         </div>
         <div class="nine columns main-col">
            <div class="row item">
               <div class="twelve columns">
                  <p>I was slowly making changes to my site, whilst I was researching and understanding how I could use Cosmos DB & an Azure Function to implement the visitor counter onto the site. I found it to be quite cumbersome, to upload my files to the $web container each time I made a change, that I wanted to make public on the site. Additional to this, I then had to purge the CDN endpoint. This meant logging into the portal each time - which I was not thrilled about...
                     <br></br>
                     I looked towards Github actions, as I was already familiar with Azure DevOps Pipelines and .yml files. I found that Github actions were free and unlimited for public repositories, so this was perfect! 
                     <br><br>
                     To automate the deployment process, I created a .yml file inside the <b>.github/workflows</b> directory of my repository. This allowed me to automatically push changes from my <b>frontend</b> folder directly to the <b>$web</b> container in my Azure Storage Account whenever I committed to the <b>main branch</b>.
                     <br></br>
                     The logic here is simple: every time I push changes to the <b>main</b> branch that affect the <b>frontend/</b> folder, the workflow uploads the updated files to the Azure Blob Storage <b>$web</b> container using the <b>az storage blob upload-batch</b> command. Immediately afterward, I purge the Azure CDN endpoint to make sure the latest version of the site is served to users. Finally, I make sure to clean up the Azure session with <b>az logout</b>.
                     <br></br>
                     Initially, I tried to run the action or the workflow file and this failed as it could not login to Azure. After a bit of frustration (and a few failed workflow runs...), I decided to properly investigate the correct way to connect GitHub Actions to Azure. I eventually came across this <a href="https://learn.microsoft.com/en-us/azure/developer/github/connect-from-azure">Microsoft guide</a>, which turned out to be exactly what I needed. Following the steps in that article, I used the Azure CLI to create a new service principal and assign it appropriate access.
                  </p>
                  <div style="text-align: center;">
                     <img src="./images/actionfails.png">
                  </div>
                  <p>
                     This returned a JSON blob with all the necessary authentication details in the format that the azure login expects. I took that entire output and added it as a new GitHub Secret called AZURE_CREDENTIALS under my repository settings.
                     <br></br>
                     After doing this, the login step in my workflow started working perfectly — and my site was automatically deploying with every commit. Success! Using this setup meant no more manual uploads or purging — just commit and push, and GitHub Actions takes care of the rest. It was a small change, but it made a massive difference to my workflow.
                  </p>
               </div>
            </div> <!-- item end -->
         </div> <!-- main-col end -->
      </div> <!-- End 8. CI/CD (Front end) -->
      <div class="row work">
         <div class="three columns header-col">
            <h1><span>9. Javascript</span></h1>
         </div>
         <div class="nine columns main-col">
            <div class="row item">
               <div class="twelve columns">
                  <p>It was now time to start building out the JavaScript that would eventually power the dynamic visitor counter on my site. While I hadn’t yet created the Azure Function or Cosmos DB to store and retrieve the actual count, I knew what the shape of the integration would look like — and I wanted to get the frontend side ready first. JavaScript was fairly familiar to me at a fundamental level, especially after having built a few React projects over the past few months. I knew I’d need a script that would: 
                  <li class="bullet">Wait until the page finishes loading</li>
                  <li class="bullet">Call an API endpoint (which I’d build later),</li>
                  <li class="bullet">And then update a specific element on the page with the count it received.</li>
                  <br>
                  To start, I added a <b>DOMContentLoaded</b> event listener so that my script would only run once the page’s HTML had fully rendered. Then, using the <b>fetch()</b> function, I planned to retrieve the count from the backend. Once I had that value, I’d target the counter element using <b>document.getElementById('counter')</b>, and replace its contents using <b>.innerText.</b>
                  <br></br>
                  Even though I didn’t have a working backend yet, I structured the code to call a placeholder URL for now, and added basic error handling in case the fetch failed — which, at this point, it always would.
                  <br></br>
                  This approach let me build and test the visual experience right away, so I’d be able to drop in the backend connection seamlessly once the API and database were up and running.

               </p>
               </div>
            </div> <!-- item end -->
         </div> <!-- main-col end -->
      </div> <!-- End 9. Javascript -->
      <div class="row work">
         <div class="three columns header-col">
            <h1><span>10. Database</span></h1>
         </div>
         <div class="nine columns main-col">
            <div class="row item">
               <div class="twelve columns">
                  <p>With the front end logic in place and ready to consume an API, it was time to set up the backend storage — starting with the database. For this challenge, I chose to use <b>Azure Cosmos DB</b>. It's a globally distributed NoSQL database service from Microsoft, and while it might have been overkill for something as simple as a visitor counter, it was a great opportunity to get hands-on with it — and it integrates beautifully with Azure Functions through bindings. I used the learning tier to keep costs down.
                  <br><br>
                  I created a <b>Cosmos DB account</b> in Azure within the same resource group, as the rest of my services, and then created;
                  <li class="bullet">A database called cmdevcosdb</li>
                  <li class="bullet">A container called Counter</li>
                  <li class="bullet">A simple document inside the container with: id: set to "1" & count: set to 0</li>
                  <br>
                  At this point, I had my database structure in place and a connection string ready to go. I initially attempted to connect directly to the Cosmos DB using just the URI and connection string from my JavaScript — but quickly ran into authentication issues. As it turns out, Cosmos DB requires properly signed authorization headers for direct access, which makes it a poor candidate for client-side interaction.
                  <br></br>
                  This was actually a good thing — exposing the database directly to the browser would have been a major security risk. Instead, it confirmed what I already suspected: I needed a secure API layer between the frontend and the database. That’s where Azure Functions would come in.
                  </p>
               </div>
            </div> <!-- item end -->
         </div> <!-- main-col end -->
      </div> <!-- End 10. Database -->
      <div class="row work">
         <div class="three columns header-col">
            <h1><span>11. API</span></h1>
         </div>
         <div class="nine columns main-col">
            <div class="row item">
               <div class="twelve columns">
                  <p>With the frontend wired up and Cosmos DB ready, the next step was to build the API layer — a middleman that could safely read and write to the database without exposing sensitive credentials to the client. For this, I used <b>Azure Functions</b> — a serverless compute service that lets you run small bits of code without worrying about infrastructure. It was perfect for this use case: a lightweight, event-driven backend triggered by HTTP requests.
                  <br></br>
                  I used the Azure Functions extension in Visual Studio Code to scaffold the project. After installing the extension, I hit F1, searched for Azure Functions: Create New Project, and followed the prompts. I chose .NET as the runtime (as I wanted to challenge myself with C#, rather than Python), selected HTTP trigger, and proceeded with the default options for the initial setup.
                  <br></br>
                  C# was new territory for me — I’d seen it used in various enterprise projects but hadn’t yet written anything production-worthy myself. This challenge gave me the perfect excuse to dive in. I quickly learned that, thanks to Azure Functions’ support for bindings, I didn’t need to write a ton of boilerplate code to interact with Cosmos DB.
                  <br></br>
                  I created a simple model called Counter with two properties: id and count. Then, I wired up the function to use input and output bindings for Cosmos DB. These bindings allowed the Azure Function to:
                  <li class="bullet">Automatically retrieve the document with id = "1" from the Counter container on invocation,</li>
                  <li class="bullet">Let me modify its properties directly in C#,</li>
                  <li class="bullet">And seamlessly write the updated version back to the database, without explicitly handling database connections or operations.</li>
                  <br>
                  To make this work, I needed the Cosmos DB connection string from the previous step. I added this to the local.settings.json file under the key AzureResumeConnectionString. This file is essential for running and testing the function locally, as it securely stores runtime configuration values without hardcoding them in the source code. When I deployed the function to Azure, I made sure to replicate the same key in the Application Settings of the Function App — keeping things consistent between environments.
                  <br></br>
                  The function itself was triggered by a simple HTTP GET request. When called, it would:
                  <br></br>
                  <li class="bullet">Retrieve the current count document from Cosmos DB.</li>
                  <li class="bullet">Increment the count value.</li>
                  <li class="bullet">Return the updated count in a JSON response.</li>
                  <br>
                  I found it incredibly powerful how the [CosmosDB] binding could handle both the input and the output just by defining them as parameters — it made the code clean and easy to follow. That said, understanding the syntax around bindings, the required attributes, and the naming conventions took a bit of trial and error.
                  <br></br>
                  Along the way, I learned:
                  <br></br>
                  <li class="bullet">How to structure function signatures with multiple bindings,</li>
                  <li class="bullet">The importance of matching partition keys and IDs correctly,</li>
                  <li class="bullet">And how valuable proper logging (ILogger) can be when debugging in a stateless, cloud-based environment.</li>
                  <br>
                  Once everything was wired up locally, I tested the function using the built-in func runtime, and set the local func API within my front-end Javascript code, and confirmed that it was correctly incrementing the value in the database and returning the updated count to the client. The added benefit of being able to run these locally, is that I did not incur a cost for running the function, so I could test this with a whole lot of trial and error!
                  <br></br>
                  Deploying the function to Azure via VS Code (using the Advanced deployment option) was seamless, and it allowed me to select the correct resource group and keep all of my services neatly together.
                  <br></br>
                  After deployment, I ran into one final issue — the frontend was failing to fetch the API, and browser dev tools pointed to CORS. I quickly updated the CORS settings in the Function App configuration to allow my frontend's domain (e.g. https://resume.cmdevelop.com) — and as soon as that was in place, everything clicked. The counter started updating live on page load, just as I’d planned.
               </p>
               </div>
            </div> <!-- item end -->
         </div> <!-- main-col end -->
      </div> <!-- End 11. API -->
      <div class="row work">
         <div class="three columns header-col">
            <h1><span>12. Tests</span></h1>
         </div>
         <div class="nine columns main-col">
            <div class="row item">
               <div class="twelve columns">
                  <p>As I was working through the Function logic, I also wanted to build in a bit of automated testing — something that would validate the API behavior before I deployed it. Since I was planning to integrate this into a backend GitHub Actions workflow (more on that next), I knew these tests could act as a safeguard: the function wouldn’t deploy if the logic ever broke.
                  <br></br>
                  I wrote a basic unit test using xUnit. Its goal was simple: simulate a request to the Azure Function, and check that the visitor count was correctly incremented by one.
                  <br></br>
                  To do this, I created mock versions of the HttpRequest and ILogger objects using a factory pattern (TestFactory), and passed them into the function along with a dummy Counter object. The test then asserted that the count value was incremented as expected.
                  <br></br>
                  While it doesn’t hit a real database or run in a hosted environment, it does validate the core logic of the Function — which is exactly what I wanted. And by placing this in the test project (tests.csproj), I was able to run this test as part of my CI/CD pipeline before deploying anything.
                  </p>
                  <div style="text-align: center;">
                     <img src="./images/tests.png">
                  </div>
               </div>
            </div> <!-- item end -->
         </div> <!-- main-col end -->
      </div> <!-- End 12. Tests -->
      <div class="row work">
         <div class="three columns header-col">
            <h1><span>13. CI/CD Back End</span></h1>
         </div>
         <div class="nine columns main-col">
            <div class="row item">
               <div class="twelve columns">
                  <p>With the frontend GitHub Actions workflow already working smoothly, I wanted to bring the same automation to the backend. My goal was simple: every time I pushed a change to the backend/ folder on the main branch, I wanted GitHub to:
                  <li class="bullet">Build the Azure Function project</li>
                  <li class="bullet">Run the unit tests I had written,</li>
                  <li class="bullet">And only deploy to Azure if those tests passed.</li>
                  <br>
                  This is exactly what my backend workflow does. Here’s the logic behind the GitHub Actions workflow I created:
                  <br></br>
                  <li class="bullet">It’s triggered by changes to anything under the backend/ path, on the main branch</li>
                  <li class="bullet">It sets up a .NET 6 environment.</li>
                  <li class="bullet">It builds the Function App from the api/ subfolder.</li>
                  <li class="bullet">Then it runs the unit tests from the tests/ folder.</li>
                  <li class="bullet">Finally — if the tests pass — it deploys the built function to Azure.</li>
                  <br>
                  This setup gave me confidence that any logic changes to the Function would be vetted automatically. The build step compiles the Function App in release mode, while the testing step runs the unit tests I had previously written to validate the core behavior — specifically ensuring the visitor count increments correctly.
                  <br></br>
                  By placing this check before deployment, I created a safety net: if any test fails, the deployment step is skipped entirely. This helps prevent pushing a broken version of the function to production — something I really valued as I was iterating quickly and learning on the fly.
                  <br></br>
                  Once the tests pass, the workflow publishes the output to Azure, using the Function App name and package path I defined in the environment variables. The workflow also logs into Azure using the credentials securely stored as a GitHub secret (the same credentials I defined for the front end), keeping everything streamlined and secure.
                  <br></br>
                  Integrating testing into the pipeline was a small but powerful step. It elevated my confidence in the changes I was making — and gave me a much deeper understanding of how CI/CD pipelines can enforce reliability through automation.
                  </p>
               </div>
            </div> <!-- item end -->
         </div> <!-- main-col end -->
      </div> <!-- End 13. CI/CD (Back end) -->
      <div class="row work">
         <div class="three columns header-col">
            <h1><span>14. IaC</span></h1>
         </div>
         <div class="nine columns main-col">
            <div class="row item">
               <div class="twelve columns">
                  <p>To wrap up the challenge, I wanted to demonstrate some Infrastructure as Code — not through another GitHub Actions workflow, since I had already showcased automation extensively, but to show how powerful and approachable Azure Bicep can be for defining resources declaratively.
                  <br></br>
                  I started by logging into the Azure Portal and downloading the existing ARM templates for the resources I had built manually. From there, I decompiled the ARM templates into Bicep, giving me a readable and editable representation of my infrastructure.
                  <br></br>
                  The process was a bit trial and error at first. I’d make changes to the Bicep file, attempt to deploy it into a new resource group, and refine it until I could get a consistent and clean deployment. This iterative process really helped me understand the resource dependencies and how Bicep handles parameters, names, and linked services.
                  <br></br>
                  One intentional decision I made was to exclude the Azure Function from the Bicep deployment. Since I already had a solid CI/CD workflow in place for deploying function code via GitHub Actions, I didn’t want to overcomplicate the infrastructure layer. Instead, I manually created the Function App from VS Code, and once my Bicep file had finished provisioning the rest of the environment (like the storage account and Cosmos DB), I simply pushed updates to the frontend and backend through the respective pipelines.
                  <br></br>
                  This gave me the best of both worlds: repeatable infrastructure deployment with Bicep, and continuous, test-driven function deployment through CI/CD. It also helped me better appreciate how manual steps, IaC, and pipelines can all work together in a flexible DevOps workflow.
                  <br></br>
                  </p>
               </div>
            </div> <!-- item end -->
         </div> <!-- main-col end -->
      </div> <!-- End 14. Infrastructure as Code -->
      <div class="row work">
         <div class="three columns header-col">
            <h1><span>15. Blog post</span></h1>
         </div>
         <div class="nine columns main-col">
            <div class="row item">
               <div class="twelve columns">
                  <p>Completing the Cloud Resume Challenge was more than just ticking off technical tasks — it was a genuinely rewarding learning journey that brought together frontend development, backend APIs, cloud services, CI/CD automation, infrastructure as code, and now, writing about it all.
                  <br></br>
                  Throughout the challenge, I pushed myself to try new tools and approaches — like working with C# and Azure Functions, writing automated tests in xUnit, structuring my deployment pipelines, and getting hands-on with Bicep. Each step helped solidify my understanding of modern cloud-native development, and by the end, I had a much more complete view of how all these pieces can work together in a real-world project.
                  <br></br>
                  And of course, there was one final step to complete the challenge: writing a blog post. Instead of publishing it on a platform like Dev.to or Hashnode, I decided to build the blog directly into my own resume site — keeping the project fully self-contained and completely mine from end to end.
                  <br></br>
                  Surprisingly, writing this blog became one of the most enjoyable parts of the whole experience. It pushed me to slow down, reflect, and explain what I’d learned in a way that someone else could follow. What started as a requirement turned into something I’ve genuinely come to enjoy — and it’s definitely sparked my interest in writing more technical content in the future.
                  <br></br>
                  If you’d like to see the full source code for this project — including the frontend, backend, infrastructure templates, and GitHub Actions workflows — you can check it out in my public GitHub repository.
                  <div style="text-align: center;">
                     <a href="https://github.com/CharlieMansell/CMDEV_az_resume"><img src="./images/github.png"></a>
                  </div>
                  </p>
               </div>
            </div> <!-- item end -->
         </div> <!-- main-col end -->
      </div> <!-- End 15. Blog post -->


   </section> <!-- Resume Section End-->

   <!-- footer
   ================================================== -->
   <footer>

      <div class="row">

         <div class="twelve columns">

            <ul class="social-links">
               <li><a href="https://www.linkedin.com/in/charliemansellprofile/"><i class="fa fa-linkedin"></i></a></li>
               <li><a href="https://github.com/CharlieMansell"><i class="fa fa-github"></i></a></li>
               <li><a href="mailto:charliemansellwork@gmail.com"><i class="fa fa-envelope"></i></a></li>
            </ul>
            <ul class="copyright">
               <a href="https://www.styleshout.com/free-templates/ceevee/"> Template by CeeVee </a>
                
            </ul>

         </div>

         <div id="go-top"><a class="smoothscroll" title="Back to Top" href="#home"><i class="icon-up-open"></i></a></div>

      </div>

   </footer> <!-- Footer End-->

   <!-- Java Script
   ================================================== -->
   <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
   <script>window.jQuery || document.write('<script src="js/jquery-1.10.2.min.js"><\/script>')</script>
   <script type="text/javascript" src="js/jquery-migrate-1.2.1.min.js"></script>

   <script src="js/jquery.flexslider.js"></script>
   <script src="js/waypoints.js"></script>
   <script src="js/jquery.fittext.js"></script>
   <script src="js/magnific-popup.js"></script>
   <script src="js/init.js"></script>
   <script type="text/javascript" src="js/counter.js"></script>
   <script src="js/main.js"></script>

</body>

</html>